<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MessagePack for C++: msgpack::packer&lt; Stream &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MessagePack for C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemsgpack.html">msgpack</a></li><li class="navelem"><a class="el" href="classmsgpack_1_1packer.html">packer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmsgpack_1_1packer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">msgpack::packer&lt; Stream &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class template that supports continuous packing.  
 <a href="classmsgpack_1_1packer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="v1_2adaptor_2adaptor__base__decl_8hpp_source.html">adaptor_base_decl.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a73d24ac5aafcbfb8f917aaedc1cc2bb7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a73d24ac5aafcbfb8f917aaedc1cc2bb7">packer</a> (Stream *s)</td></tr>
<tr class="memdesc:a73d24ac5aafcbfb8f917aaedc1cc2bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a73d24ac5aafcbfb8f917aaedc1cc2bb7">More...</a><br /></td></tr>
<tr class="separator:a73d24ac5aafcbfb8f917aaedc1cc2bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac968f12bfb1a629b571539a3e9b5bce7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#ac968f12bfb1a629b571539a3e9b5bce7">packer</a> (Stream &amp;s)</td></tr>
<tr class="memdesc:ac968f12bfb1a629b571539a3e9b5bce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ac968f12bfb1a629b571539a3e9b5bce7">More...</a><br /></td></tr>
<tr class="separator:ac968f12bfb1a629b571539a3e9b5bce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad936992e4324e8a5a31d53745fef7e09"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad936992e4324e8a5a31d53745fef7e09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#ad936992e4324e8a5a31d53745fef7e09">pack</a> (const T &amp;v)</td></tr>
<tr class="memdesc:ad936992e4324e8a5a31d53745fef7e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing function template.  <a href="#ad936992e4324e8a5a31d53745fef7e09">More...</a><br /></td></tr>
<tr class="separator:ad936992e4324e8a5a31d53745fef7e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f9ec42acac1677e6230bf8b7173d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a53f9ec42acac1677e6230bf8b7173d9c">pack_uint8</a> (uint8_t d)</td></tr>
<tr class="memdesc:a53f9ec42acac1677e6230bf8b7173d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing uint8.  <a href="#a53f9ec42acac1677e6230bf8b7173d9c">More...</a><br /></td></tr>
<tr class="separator:a53f9ec42acac1677e6230bf8b7173d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf92cb3cb74374a7b64455ba5b2850ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#abf92cb3cb74374a7b64455ba5b2850ba">pack_uint16</a> (uint16_t d)</td></tr>
<tr class="memdesc:abf92cb3cb74374a7b64455ba5b2850ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing uint16.  <a href="#abf92cb3cb74374a7b64455ba5b2850ba">More...</a><br /></td></tr>
<tr class="separator:abf92cb3cb74374a7b64455ba5b2850ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341e64b414395108295a014a35cc4ea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a341e64b414395108295a014a35cc4ea5">pack_uint32</a> (uint32_t d)</td></tr>
<tr class="memdesc:a341e64b414395108295a014a35cc4ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing uint32.  <a href="#a341e64b414395108295a014a35cc4ea5">More...</a><br /></td></tr>
<tr class="separator:a341e64b414395108295a014a35cc4ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a1f1b9066d2a8e25a9e4ae697a2dcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#ae5a1f1b9066d2a8e25a9e4ae697a2dcb">pack_uint64</a> (uint64_t d)</td></tr>
<tr class="memdesc:ae5a1f1b9066d2a8e25a9e4ae697a2dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing uint16.  <a href="#ae5a1f1b9066d2a8e25a9e4ae697a2dcb">More...</a><br /></td></tr>
<tr class="separator:ae5a1f1b9066d2a8e25a9e4ae697a2dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c93e0716843a658b79ae187caa3fc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#aa8c93e0716843a658b79ae187caa3fc3">pack_int8</a> (int8_t d)</td></tr>
<tr class="memdesc:aa8c93e0716843a658b79ae187caa3fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing int8.  <a href="#aa8c93e0716843a658b79ae187caa3fc3">More...</a><br /></td></tr>
<tr class="separator:aa8c93e0716843a658b79ae187caa3fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c788bca228cb5c7cb7db0ff4df52cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a41c788bca228cb5c7cb7db0ff4df52cb">pack_int16</a> (int16_t d)</td></tr>
<tr class="memdesc:a41c788bca228cb5c7cb7db0ff4df52cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing int16.  <a href="#a41c788bca228cb5c7cb7db0ff4df52cb">More...</a><br /></td></tr>
<tr class="separator:a41c788bca228cb5c7cb7db0ff4df52cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362c602fb24fa71e485f5006b6a91056"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a362c602fb24fa71e485f5006b6a91056">pack_int32</a> (int32_t d)</td></tr>
<tr class="memdesc:a362c602fb24fa71e485f5006b6a91056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing int32.  <a href="#a362c602fb24fa71e485f5006b6a91056">More...</a><br /></td></tr>
<tr class="separator:a362c602fb24fa71e485f5006b6a91056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1351410e46a4ab831a3034a59f6c02a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#ae1351410e46a4ab831a3034a59f6c02a">pack_int64</a> (int64_t d)</td></tr>
<tr class="memdesc:ae1351410e46a4ab831a3034a59f6c02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing int32.  <a href="#ae1351410e46a4ab831a3034a59f6c02a">More...</a><br /></td></tr>
<tr class="separator:ae1351410e46a4ab831a3034a59f6c02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5d862db269817115e99e85f35a532c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#afc5d862db269817115e99e85f35a532c">pack_fix_uint8</a> (uint8_t d)</td></tr>
<tr class="memdesc:afc5d862db269817115e99e85f35a532c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing uint8 (fixed packed type).  <a href="#afc5d862db269817115e99e85f35a532c">More...</a><br /></td></tr>
<tr class="separator:afc5d862db269817115e99e85f35a532c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fb4643e92d848275f8c8811587f20e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#aa5fb4643e92d848275f8c8811587f20e">pack_fix_uint16</a> (uint16_t d)</td></tr>
<tr class="memdesc:aa5fb4643e92d848275f8c8811587f20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing uint8 (fixed packed type).  <a href="#aa5fb4643e92d848275f8c8811587f20e">More...</a><br /></td></tr>
<tr class="separator:aa5fb4643e92d848275f8c8811587f20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68ee2c065888aa8f544ab2936731a89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#ab68ee2c065888aa8f544ab2936731a89">pack_fix_uint32</a> (uint32_t d)</td></tr>
<tr class="memdesc:ab68ee2c065888aa8f544ab2936731a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing uint8 (fixed packed type).  <a href="#ab68ee2c065888aa8f544ab2936731a89">More...</a><br /></td></tr>
<tr class="separator:ab68ee2c065888aa8f544ab2936731a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a90c6932565177f025a349d2b7efba1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a3a90c6932565177f025a349d2b7efba1">pack_fix_uint64</a> (uint64_t d)</td></tr>
<tr class="memdesc:a3a90c6932565177f025a349d2b7efba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing uint8 (fixed packed type).  <a href="#a3a90c6932565177f025a349d2b7efba1">More...</a><br /></td></tr>
<tr class="separator:a3a90c6932565177f025a349d2b7efba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc0eb3ff2052a9bbaf3273dfae0df2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a5cc0eb3ff2052a9bbaf3273dfae0df2e">pack_fix_int8</a> (int8_t d)</td></tr>
<tr class="memdesc:a5cc0eb3ff2052a9bbaf3273dfae0df2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing uint8 (fixed packed type).  <a href="#a5cc0eb3ff2052a9bbaf3273dfae0df2e">More...</a><br /></td></tr>
<tr class="separator:a5cc0eb3ff2052a9bbaf3273dfae0df2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fbf5f4de03cfe5b476ff328e75f4cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#ab8fbf5f4de03cfe5b476ff328e75f4cd">pack_fix_int16</a> (int16_t d)</td></tr>
<tr class="memdesc:ab8fbf5f4de03cfe5b476ff328e75f4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing uint8 (fixed packed type).  <a href="#ab8fbf5f4de03cfe5b476ff328e75f4cd">More...</a><br /></td></tr>
<tr class="separator:ab8fbf5f4de03cfe5b476ff328e75f4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b21d51a224f8bbfe322af8774d12c86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a9b21d51a224f8bbfe322af8774d12c86">pack_fix_int32</a> (int32_t d)</td></tr>
<tr class="memdesc:a9b21d51a224f8bbfe322af8774d12c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing uint8 (fixed packed type).  <a href="#a9b21d51a224f8bbfe322af8774d12c86">More...</a><br /></td></tr>
<tr class="separator:a9b21d51a224f8bbfe322af8774d12c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374c0b3708a54159a0fe637fff50cfdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a374c0b3708a54159a0fe637fff50cfdf">pack_fix_int64</a> (int64_t d)</td></tr>
<tr class="memdesc:a374c0b3708a54159a0fe637fff50cfdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing uint8 (fixed packed type).  <a href="#a374c0b3708a54159a0fe637fff50cfdf">More...</a><br /></td></tr>
<tr class="separator:a374c0b3708a54159a0fe637fff50cfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f8d2a55e81c4d2253e9c9fe9d191f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#aa9f8d2a55e81c4d2253e9c9fe9d191f8">pack_char</a> (char d)</td></tr>
<tr class="memdesc:aa9f8d2a55e81c4d2253e9c9fe9d191f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing char.  <a href="#aa9f8d2a55e81c4d2253e9c9fe9d191f8">More...</a><br /></td></tr>
<tr class="separator:aa9f8d2a55e81c4d2253e9c9fe9d191f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6658c16f3d61794ace88f6be0b8af71f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a6658c16f3d61794ace88f6be0b8af71f">pack_signed_char</a> (signed char d)</td></tr>
<tr class="memdesc:a6658c16f3d61794ace88f6be0b8af71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing signed char.  <a href="#a6658c16f3d61794ace88f6be0b8af71f">More...</a><br /></td></tr>
<tr class="separator:a6658c16f3d61794ace88f6be0b8af71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2605d4b70f7135e7dbe445543bbc85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a1a2605d4b70f7135e7dbe445543bbc85">pack_short</a> (short d)</td></tr>
<tr class="memdesc:a1a2605d4b70f7135e7dbe445543bbc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing short.  <a href="#a1a2605d4b70f7135e7dbe445543bbc85">More...</a><br /></td></tr>
<tr class="separator:a1a2605d4b70f7135e7dbe445543bbc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaf662cce1c8f9640d76fb3b2999c69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a2eaf662cce1c8f9640d76fb3b2999c69">pack_int</a> (int d)</td></tr>
<tr class="memdesc:a2eaf662cce1c8f9640d76fb3b2999c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing int.  <a href="#a2eaf662cce1c8f9640d76fb3b2999c69">More...</a><br /></td></tr>
<tr class="separator:a2eaf662cce1c8f9640d76fb3b2999c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a63eed08c8e1108abdf871559262e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#ad9a63eed08c8e1108abdf871559262e5">pack_long</a> (long d)</td></tr>
<tr class="memdesc:ad9a63eed08c8e1108abdf871559262e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing long.  <a href="#ad9a63eed08c8e1108abdf871559262e5">More...</a><br /></td></tr>
<tr class="separator:ad9a63eed08c8e1108abdf871559262e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b3d4a90d09c85c9fc66085ccf983bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#aa8b3d4a90d09c85c9fc66085ccf983bf">pack_long_long</a> (long long d)</td></tr>
<tr class="memdesc:aa8b3d4a90d09c85c9fc66085ccf983bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing long long.  <a href="#aa8b3d4a90d09c85c9fc66085ccf983bf">More...</a><br /></td></tr>
<tr class="separator:aa8b3d4a90d09c85c9fc66085ccf983bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e21564a3032eec8d81fcf04cf2e3a9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a7e21564a3032eec8d81fcf04cf2e3a9d">pack_unsigned_char</a> (unsigned char d)</td></tr>
<tr class="memdesc:a7e21564a3032eec8d81fcf04cf2e3a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing unsigned char.  <a href="#a7e21564a3032eec8d81fcf04cf2e3a9d">More...</a><br /></td></tr>
<tr class="separator:a7e21564a3032eec8d81fcf04cf2e3a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b07b6f50010a25723924becb2f0049f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a4b07b6f50010a25723924becb2f0049f">pack_unsigned_short</a> (unsigned short d)</td></tr>
<tr class="memdesc:a4b07b6f50010a25723924becb2f0049f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing unsigned short.  <a href="#a4b07b6f50010a25723924becb2f0049f">More...</a><br /></td></tr>
<tr class="separator:a4b07b6f50010a25723924becb2f0049f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b19cb586896d27c2a189e29ba5da05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a76b19cb586896d27c2a189e29ba5da05">pack_unsigned_int</a> (unsigned int d)</td></tr>
<tr class="memdesc:a76b19cb586896d27c2a189e29ba5da05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing unsigned int.  <a href="#a76b19cb586896d27c2a189e29ba5da05">More...</a><br /></td></tr>
<tr class="separator:a76b19cb586896d27c2a189e29ba5da05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda055796ee2b592252127e6597e4bb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#acda055796ee2b592252127e6597e4bb9">pack_unsigned_long</a> (unsigned long d)</td></tr>
<tr class="memdesc:acda055796ee2b592252127e6597e4bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing unsigned long.  <a href="#acda055796ee2b592252127e6597e4bb9">More...</a><br /></td></tr>
<tr class="separator:acda055796ee2b592252127e6597e4bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bc770dd6b18e5548bbb05cbb53f430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#ab9bc770dd6b18e5548bbb05cbb53f430">pack_unsigned_long_long</a> (unsigned long long d)</td></tr>
<tr class="memdesc:ab9bc770dd6b18e5548bbb05cbb53f430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing unsigned long long.  <a href="#ab9bc770dd6b18e5548bbb05cbb53f430">More...</a><br /></td></tr>
<tr class="separator:ab9bc770dd6b18e5548bbb05cbb53f430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acead48b8317443b9faeb0c8ff907d94d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#acead48b8317443b9faeb0c8ff907d94d">pack_float</a> (float d)</td></tr>
<tr class="memdesc:acead48b8317443b9faeb0c8ff907d94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing float.  <a href="#acead48b8317443b9faeb0c8ff907d94d">More...</a><br /></td></tr>
<tr class="separator:acead48b8317443b9faeb0c8ff907d94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5024615733a43ba87473fe7b58675237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a5024615733a43ba87473fe7b58675237">pack_double</a> (double d)</td></tr>
<tr class="memdesc:a5024615733a43ba87473fe7b58675237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing double.  <a href="#a5024615733a43ba87473fe7b58675237">More...</a><br /></td></tr>
<tr class="separator:a5024615733a43ba87473fe7b58675237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8529ab3e807f43304ca88cf1c4378dbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a8529ab3e807f43304ca88cf1c4378dbf">pack_nil</a> ()</td></tr>
<tr class="memdesc:a8529ab3e807f43304ca88cf1c4378dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing nil.  <a href="#a8529ab3e807f43304ca88cf1c4378dbf">More...</a><br /></td></tr>
<tr class="separator:a8529ab3e807f43304ca88cf1c4378dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b903cb70cffe8de7e62e696204c1df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a76b903cb70cffe8de7e62e696204c1df">pack_true</a> ()</td></tr>
<tr class="memdesc:a76b903cb70cffe8de7e62e696204c1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing true.  <a href="#a76b903cb70cffe8de7e62e696204c1df">More...</a><br /></td></tr>
<tr class="separator:a76b903cb70cffe8de7e62e696204c1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ef7a538b566fb71dc38a33fcdb82fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a80ef7a538b566fb71dc38a33fcdb82fe">pack_false</a> ()</td></tr>
<tr class="memdesc:a80ef7a538b566fb71dc38a33fcdb82fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing false.  <a href="#a80ef7a538b566fb71dc38a33fcdb82fe">More...</a><br /></td></tr>
<tr class="separator:a80ef7a538b566fb71dc38a33fcdb82fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccfa8c1c0e01cafd0020bca5bbd8cbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#acccfa8c1c0e01cafd0020bca5bbd8cbb">pack_array</a> (uint32_t n)</td></tr>
<tr class="memdesc:acccfa8c1c0e01cafd0020bca5bbd8cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing array header and size.  <a href="#acccfa8c1c0e01cafd0020bca5bbd8cbb">More...</a><br /></td></tr>
<tr class="separator:acccfa8c1c0e01cafd0020bca5bbd8cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56eab2094abd6467245ba135fe884f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a56eab2094abd6467245ba135fe884f1e">pack_map</a> (uint32_t n)</td></tr>
<tr class="memdesc:a56eab2094abd6467245ba135fe884f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing map header and size.  <a href="#a56eab2094abd6467245ba135fe884f1e">More...</a><br /></td></tr>
<tr class="separator:a56eab2094abd6467245ba135fe884f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d5a612c8ee63afa589f40bd7b18157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#ab9d5a612c8ee63afa589f40bd7b18157">pack_str</a> (uint32_t l)</td></tr>
<tr class="memdesc:ab9d5a612c8ee63afa589f40bd7b18157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing str header and length.  <a href="#ab9d5a612c8ee63afa589f40bd7b18157">More...</a><br /></td></tr>
<tr class="separator:ab9d5a612c8ee63afa589f40bd7b18157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860e40e4e394e421fa25d5cb2ebb6176"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a860e40e4e394e421fa25d5cb2ebb6176">pack_str_body</a> (const char *b, uint32_t l)</td></tr>
<tr class="memdesc:a860e40e4e394e421fa25d5cb2ebb6176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing str body.  <a href="#a860e40e4e394e421fa25d5cb2ebb6176">More...</a><br /></td></tr>
<tr class="separator:a860e40e4e394e421fa25d5cb2ebb6176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b934eab99f33b1558c447314d80592f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a1b934eab99f33b1558c447314d80592f">pack_v4raw</a> (uint32_t l)</td></tr>
<tr class="memdesc:a1b934eab99f33b1558c447314d80592f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing raw (v4) header and length.  <a href="#a1b934eab99f33b1558c447314d80592f">More...</a><br /></td></tr>
<tr class="separator:a1b934eab99f33b1558c447314d80592f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743bc909852b9ff89e5c5d033d0aed25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a743bc909852b9ff89e5c5d033d0aed25">pack_v4raw_body</a> (const char *b, uint32_t l)</td></tr>
<tr class="memdesc:a743bc909852b9ff89e5c5d033d0aed25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing raw (v4) body.  <a href="#a743bc909852b9ff89e5c5d033d0aed25">More...</a><br /></td></tr>
<tr class="separator:a743bc909852b9ff89e5c5d033d0aed25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a942dcb74b06881281b97402cdb44e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a4a942dcb74b06881281b97402cdb44e5">pack_bin</a> (uint32_t l)</td></tr>
<tr class="memdesc:a4a942dcb74b06881281b97402cdb44e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing bin header and length.  <a href="#a4a942dcb74b06881281b97402cdb44e5">More...</a><br /></td></tr>
<tr class="separator:a4a942dcb74b06881281b97402cdb44e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eec4da415fa885d540c6d9a310e00be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a9eec4da415fa885d540c6d9a310e00be">pack_bin_body</a> (const char *b, uint32_t l)</td></tr>
<tr class="memdesc:a9eec4da415fa885d540c6d9a310e00be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing bin body.  <a href="#a9eec4da415fa885d540c6d9a310e00be">More...</a><br /></td></tr>
<tr class="separator:a9eec4da415fa885d540c6d9a310e00be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1c5c8e5e5dd0b69e4041b0e7e90765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a8b1c5c8e5e5dd0b69e4041b0e7e90765">pack_ext</a> (size_t l, int8_t type)</td></tr>
<tr class="memdesc:a8b1c5c8e5e5dd0b69e4041b0e7e90765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing ext header, type, and length.  <a href="#a8b1c5c8e5e5dd0b69e4041b0e7e90765">More...</a><br /></td></tr>
<tr class="separator:a8b1c5c8e5e5dd0b69e4041b0e7e90765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7faa01e34eb7fa41968ece1be316ee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#ac7faa01e34eb7fa41968ece1be316ee4">pack_ext_body</a> (const char *b, uint32_t l)</td></tr>
<tr class="memdesc:ac7faa01e34eb7fa41968ece1be316ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packing ext body.  <a href="#ac7faa01e34eb7fa41968ece1be316ee4">More...</a><br /></td></tr>
<tr class="separator:ac7faa01e34eb7fa41968ece1be316ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e15fb4c40248adc4e2b841b01cec25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a24e15fb4c40248adc4e2b841b01cec25">packer</a> (const <a class="el" href="classmsgpack_1_1packer.html">packer</a> &amp;)=delete</td></tr>
<tr class="separator:a24e15fb4c40248adc4e2b841b01cec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e927757da18afa649566324e0bc4114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">packer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a4e927757da18afa649566324e0bc4114">operator=</a> (const <a class="el" href="classmsgpack_1_1packer.html">packer</a> &amp;)=delete</td></tr>
<tr class="separator:a4e927757da18afa649566324e0bc4114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f601ebd030879c6124a5915d922d072"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#a2f601ebd030879c6124a5915d922d072">packer</a> ()=delete</td></tr>
<tr class="separator:a2f601ebd030879c6124a5915d922d072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae787682cb2fa52186ed788b3e0103d1c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae787682cb2fa52186ed788b3e0103d1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html#ae787682cb2fa52186ed788b3e0103d1c">pack</a> (const T &amp;v)</td></tr>
<tr class="separator:ae787682cb2fa52186ed788b3e0103d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Stream&gt;<br />
class msgpack::packer&lt; Stream &gt;</h3>

<p>The class template that supports continuous packing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stream</td><td>Any type that have a member function <code>Stream write(const char*, size_t s)</code> </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a73d24ac5aafcbfb8f917aaedc1cc2bb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::<a class="el" href="classmsgpack_1_1packer.html">packer</a> </td>
          <td>(</td>
          <td class="paramtype">Stream *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>This constructor is left for compatibility. Use <code><a class="el" href="classmsgpack_1_1packer.html#a73d24ac5aafcbfb8f917aaedc1cc2bb7" title="Constructor. ">packer(Stream* s)</a></code> instead of the constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A pointer to packing destination stream object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac968f12bfb1a629b571539a3e9b5bce7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::<a class="el" href="classmsgpack_1_1packer.html">packer</a> </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Packing destination stream object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24e15fb4c40248adc4e2b841b01cec25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::<a class="el" href="classmsgpack_1_1packer.html">packer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2f601ebd030879c6124a5915d922d072"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::<a class="el" href="classmsgpack_1_1packer.html">packer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4e927757da18afa649566324e0bc4114"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad936992e4324e8a5a31d53745fef7e09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt;Stream&gt;&amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packing function template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1reference__wrapper_3_01_t_01_4_01_4.html#ab33dde11df3cb4ed917b68245a06d194">msgpack::adaptor::pack&lt; std::reference_wrapper&lt; T &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1vector_3_01bool_00_01_alloc_01_4_01_4.html#a5f82ba41d0947762892ffe4b45d296b1">msgpack::adaptor::pack&lt; std::vector&lt; bool, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unique__ptr_3_01_t_01_4_01_4.html#a3032426d91729dea7bf2f54216c50750">msgpack::adaptor::pack&lt; std::unique_ptr&lt; T &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1shared__ptr_3_01_t_01_4_01_4.html#aa0fde423b60c4dcf403ccbb5e156d9d6">msgpack::adaptor::pack&lt; std::shared_ptr&lt; T &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.html#a7f849184d2d1dd8f5034882b928ea5f2">msgpack::adaptor::pack&lt; std::pair&lt; T1, T2 &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1forward__list_3_01_t_00_01_alloc_01_4_01_4.html#a1f77065a8b2030527ed56ea36d185e17">msgpack::adaptor::pack&lt; std::forward_list&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unordered__set_3_01_key_00_01_hash_00_01_compare_00_01_alloc_01_4_01_4.html#a859b67e28c723118446247f057205bc0">msgpack::adaptor::pack&lt; std::unordered_set&lt; Key, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unordered__map_3_01_k_00_01_v_00_01_hash_00_01_compare_00_01_alloc_01_4_01_4.html#a44b14e270d738552c27a78e6fe79c72d">msgpack::adaptor::pack&lt; std::unordered_map&lt; K, V, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1list_3_01_t_00_01_alloc_01_4_01_4.html#ad748d5f058b8fb7145cc40405d018118">msgpack::adaptor::pack&lt; std::list&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01boost_1_1optional_3_01_t_01_4_01_4.html#a32e3ee1d03e60b0aea53e4b34ecdb2ba">msgpack::adaptor::pack&lt; boost::optional&lt; T &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1deque_3_01_t_00_01_alloc_01_4_01_4.html#ae223444c92f31b1de740393fa059426a">msgpack::adaptor::pack&lt; std::deque&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1set_3_01_t_00_01_compare_00_01_alloc_01_4_01_4.html#abccad06348ef9f16f5f35b4fc5a38ab2">msgpack::adaptor::pack&lt; std::set&lt; T, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1vector_3_01_t_00_01_alloc_01_4_01_4.html#ae650b6471c2806c28a85cac2eddbbb0e">msgpack::adaptor::pack&lt; std::vector&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1assoc__vector_3_01_k_00_01_v_00_01_compare_00_01_alloc_01_4_01_4.html#a3b379cea5dfe498024fd2f96fd9634ed">msgpack::adaptor::pack&lt; type::assoc_vector&lt; K, V, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a9ee0c7b2a6274e9e2dd9b1c2391b4aa9">msgpack::adaptor::pack&lt; std::array&lt; T, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1type_1_1array__ref_3_01_t_01_4_01_4.html#a6ee56f3cfce847f2d7a1c7e1411cb331">msgpack::adaptor::pack&lt; msgpack::type::array_ref&lt; T &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unordered__multiset_3_01_key_00_01_hash_00_01_compare_00_01_alloc_01_4_01_4.html#ad8920d9cb9e0643dcd721b7b50841668">msgpack::adaptor::pack&lt; std::unordered_multiset&lt; Key, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unordered__multimap_3_01_k_00_01_v_00_01_hash_00_01_compare_00_01_alloc_01_4_01_4.html#aa72c9d6fd9cae57810917c1242ca12a6">msgpack::adaptor::pack&lt; std::unordered_multimap&lt; K, V, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1multiset_3_01_t_00_01_compare_00_01_alloc_01_4_01_4.html#a53f8e9a66272b15078950032e33de98d">msgpack::adaptor::pack&lt; std::multiset&lt; T, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1map_3_01_k_00_01_v_00_01_compare_00_01_alloc_01_4_01_4.html#a8cf6af75da6d8a82369a395f14828552">msgpack::adaptor::pack&lt; std::map&lt; K, V, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1multimap_3_01_k_00_01_v_00_01_compare_00_01_alloc_01_4_01_4.html#acd3211d8657a30299bb3cd05e2b3b53f">msgpack::adaptor::pack&lt; std::multimap&lt; K, V, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1tuple_3_4_01_4.html#a841944949d97b3a40ad7ce45451eff48">msgpack::adaptor::pack&lt; type::tuple&lt;&gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1_std_tuple_packer.html#abf2b6895df201b5aaa80a2545bb421b5">msgpack::StdTuplePacker&lt; Stream, Tuple, N &gt;::pack()</a>, <a class="el" href="structmsgpack_1_1_msgpack_tuple_packer.html#a831287eb801ad56dc8a6ea9c86e7b0a9">msgpack::MsgpackTuplePacker&lt; Stream, Tuple, N &gt;::pack()</a>, <a class="el" href="structmsgpack_1_1_msgpack_tuple_packer_3_01_stream_00_01_tuple_00_011_01_4.html#a0e2e8209545d1808703bb15890b987e3">msgpack::MsgpackTuplePacker&lt; Stream, Tuple, 1 &gt;::pack()</a>, and <a class="el" href="namespacemsgpack.html#a129e066299f13283fbf9b35233ca4274">msgpack::pack()</a>.</p>

</div>
</div>
<a class="anchor" id="ae787682cb2fa52186ed788b3e0103d1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt;Stream&gt;&amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="namespacemsgpack.html#a386d2da72f0ff80671033a3631f5f08e">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="acccfa8c1c0e01cafd0020bca5bbd8cbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_array </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing array header and size. </p>
<p>The packed type is array header and array size. You need to pack <code>n</code> msgpack objects following this header and size. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#array-format-family">https://github.com/msgpack/msgpack/blob/master/spec.md#array-format-family</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of array elements (array size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1vector_3_01bool_00_01_alloc_01_4_01_4.html#a5f82ba41d0947762892ffe4b45d296b1">msgpack::adaptor::pack&lt; std::vector&lt; bool, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1tuple_3_01_args_8_8_8_01_4_01_4.html#a332281152d1278eaa78c8917225fd53a">msgpack::adaptor::pack&lt; std::tuple&lt; Args... &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.html#a7f849184d2d1dd8f5034882b928ea5f2">msgpack::adaptor::pack&lt; std::pair&lt; T1, T2 &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1forward__list_3_01_t_00_01_alloc_01_4_01_4.html#a1f77065a8b2030527ed56ea36d185e17">msgpack::adaptor::pack&lt; std::forward_list&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unordered__set_3_01_key_00_01_hash_00_01_compare_00_01_alloc_01_4_01_4.html#a859b67e28c723118446247f057205bc0">msgpack::adaptor::pack&lt; std::unordered_set&lt; Key, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1list_3_01_t_00_01_alloc_01_4_01_4.html#ad748d5f058b8fb7145cc40405d018118">msgpack::adaptor::pack&lt; std::list&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1deque_3_01_t_00_01_alloc_01_4_01_4.html#ae223444c92f31b1de740393fa059426a">msgpack::adaptor::pack&lt; std::deque&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1set_3_01_t_00_01_compare_00_01_alloc_01_4_01_4.html#abccad06348ef9f16f5f35b4fc5a38ab2">msgpack::adaptor::pack&lt; std::set&lt; T, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1vector_3_01_t_00_01_alloc_01_4_01_4.html#ae650b6471c2806c28a85cac2eddbbb0e">msgpack::adaptor::pack&lt; std::vector&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1type_1_1tuple_3_01_args_8_8_8_01_4_01_4.html#a001e3142ea278a241119c7c871a84d79">msgpack::adaptor::pack&lt; msgpack::type::tuple&lt; Args... &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a9ee0c7b2a6274e9e2dd9b1c2391b4aa9">msgpack::adaptor::pack&lt; std::array&lt; T, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01_t_00_01typename_01msgpack_1_1enable__if_3_01boost_1_1fusio73aeebb2a9e306de0d1b05b0d96ad817.html#a8066319a2771bb44e89582fd61d2d7f3">msgpack::adaptor::pack&lt; T, typename msgpack::enable_if&lt; boost::fusion::traits::is_sequence&lt; T &gt;::value &gt;::type &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1type_1_1array__ref_3_01_t_01_4_01_4.html#a6ee56f3cfce847f2d7a1c7e1411cb331">msgpack::adaptor::pack&lt; msgpack::type::array_ref&lt; T &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unordered__multiset_3_01_key_00_01_hash_00_01_compare_00_01_alloc_01_4_01_4.html#ad8920d9cb9e0643dcd721b7b50841668">msgpack::adaptor::pack&lt; std::unordered_multiset&lt; Key, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1multiset_3_01_t_00_01_compare_00_01_alloc_01_4_01_4.html#a53f8e9a66272b15078950032e33de98d">msgpack::adaptor::pack&lt; std::multiset&lt; T, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1tuple_3_4_01_4.html#a841944949d97b3a40ad7ce45451eff48">msgpack::adaptor::pack&lt; type::tuple&lt;&gt; &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a4a942dcb74b06881281b97402cdb44e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_bin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing bin header and length. </p>
<p>The packed type is bin header and length. The minimum byte size length expression is used. You need to call <code><a class="el" href="classmsgpack_1_1packer.html#a9eec4da415fa885d540c6d9a310e00be" title="Packing bin body. ">pack_bin_body(const char* b, uint32_t l)</a></code> after this function calling with the same <code>l</code> value. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#bin-format-family">https://github.com/msgpack/msgpack/blob/master/spec.md#bin-format-family</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The length of string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1array_3_01char_00_01_n_01_4_01_4.html#a235857d3bfbfca5d0caf1e55c5eb635f">msgpack::adaptor::pack&lt; std::array&lt; char, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1array_3_01unsigned_01char_00_01_n_01_4_01_4.html#afce82bce31832fa0e9856d3f4a60b92b">msgpack::adaptor::pack&lt; std::array&lt; unsigned char, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1vector_3_01char_00_01_alloc_01_4_01_4.html#ab58ac98d3054e6a1ba43a9a2a33451d2">msgpack::adaptor::pack&lt; std::vector&lt; char, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1vector_3_01unsigned_01char_00_01_alloc_01_4_01_4.html#a934b04f78eb220da7bf40ff59b77ca0f">msgpack::adaptor::pack&lt; std::vector&lt; unsigned char, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1raw__ref_01_4.html#aabce440a2560a35f5efd6757a7bba10b">msgpack::adaptor::pack&lt; type::raw_ref &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a9eec4da415fa885d540c6d9a310e00be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_bin_body </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing bin body. </p>
<p>You need to call this function just after <code><a class="el" href="classmsgpack_1_1packer.html#a4a942dcb74b06881281b97402cdb44e5" title="Packing bin header and length. ">pack_bin(uint32_t l)</a></code> calling. The value <code>l</code> should be the same as <code><a class="el" href="classmsgpack_1_1packer.html#a4a942dcb74b06881281b97402cdb44e5" title="Packing bin header and length. ">pack_bin(uint32_t l)</a></code> argument <code>l</code>. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#bin-format-family">https://github.com/msgpack/msgpack/blob/master/spec.md#bin-format-family</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The length of string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1array_3_01char_00_01_n_01_4_01_4.html#a235857d3bfbfca5d0caf1e55c5eb635f">msgpack::adaptor::pack&lt; std::array&lt; char, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1array_3_01unsigned_01char_00_01_n_01_4_01_4.html#afce82bce31832fa0e9856d3f4a60b92b">msgpack::adaptor::pack&lt; std::array&lt; unsigned char, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1vector_3_01char_00_01_alloc_01_4_01_4.html#ab58ac98d3054e6a1ba43a9a2a33451d2">msgpack::adaptor::pack&lt; std::vector&lt; char, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1vector_3_01unsigned_01char_00_01_alloc_01_4_01_4.html#a934b04f78eb220da7bf40ff59b77ca0f">msgpack::adaptor::pack&lt; std::vector&lt; unsigned char, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1raw__ref_01_4.html#aabce440a2560a35f5efd6757a7bba10b">msgpack::adaptor::pack&lt; type::raw_ref &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9f8d2a55e81c4d2253e9c9fe9d191f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_char </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing char. </p>
<p>The byte size of the packed data depends on <code>d</code>. If <code>d</code> is zero or positive, the packed type is positive fixnum, or uint*, else the packed type is negative fixnum, or int* The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01char_01_4.html#a8c9f1d83835cbf7281309c795f1e5a5f">msgpack::adaptor::pack&lt; char &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a5024615733a43ba87473fe7b58675237"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_double </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing double. </p>
<p>The packed type is float64. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-float">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-float</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01double_01_4.html#af8a4929965027341acfb75ed7c0b7651">msgpack::adaptor::pack&lt; double &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b1c5c8e5e5dd0b69e4041b0e7e90765"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_ext </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing ext header, type, and length. </p>
<p>The packed type is ext. The minimum byte size length expression is used. The length 1, 2, 4, 8, and 16 can be encoded in the header. You need to call <code><a class="el" href="classmsgpack_1_1packer.html#ac7faa01e34eb7fa41968ece1be316ee4" title="Packing ext body. ">pack_ext_body(const char* b, uint32_t l)</a></code> after this function calling with the same <code>l</code> value. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-ext">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-ext</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The length of string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1type_1_1ext_01_4.html#a9bf258387335104b6d02c7128fb702cc">msgpack::adaptor::pack&lt; msgpack::type::ext &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1type_1_1ext__ref_01_4.html#ac83794364b3be18c8a62638953153903">msgpack::adaptor::pack&lt; msgpack::type::ext_ref &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7faa01e34eb7fa41968ece1be316ee4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_ext_body </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing ext body. </p>
<p>You need to call this function just after <code><a class="el" href="classmsgpack_1_1packer.html#a8b1c5c8e5e5dd0b69e4041b0e7e90765" title="Packing ext header, type, and length. ">pack_ext(size_t l, int8_t type)</a></code> calling. The value <code>l</code> should be the same as <code><a class="el" href="classmsgpack_1_1packer.html#a8b1c5c8e5e5dd0b69e4041b0e7e90765" title="Packing ext header, type, and length. ">pack_ext(size_t l, int8_t type)</a></code> argument <code>l</code>. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#bin-format-family">https://github.com/msgpack/msgpack/blob/master/spec.md#bin-format-family</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The length of string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1type_1_1ext_01_4.html#a9bf258387335104b6d02c7128fb702cc">msgpack::adaptor::pack&lt; msgpack::type::ext &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1type_1_1ext__ref_01_4.html#ac83794364b3be18c8a62638953153903">msgpack::adaptor::pack&lt; msgpack::type::ext_ref &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a80ef7a538b566fb71dc38a33fcdb82fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_false </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing false. </p>
<p>The packed type is bool, value is false. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#bool-format-family">https://github.com/msgpack/msgpack/blob/master/spec.md#bool-format-family</a></p>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01bool_01_4.html#a47ca02dc54aae6c18750609e90adcbd7">msgpack::adaptor::pack&lt; bool &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8fbf5f4de03cfe5b476ff328e75f4cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_fix_int16 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing uint8 (fixed packed type). </p>
<p>The packed type is always int16. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1fix__int16_01_4.html#aaa8d220f45deea077f8477e4681995b1">msgpack::adaptor::pack&lt; type::fix_int16 &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b21d51a224f8bbfe322af8774d12c86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_fix_int32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing uint8 (fixed packed type). </p>
<p>The packed type is always int32. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1fix__int32_01_4.html#a0f7236efea6f73965a644d275bdccdc1">msgpack::adaptor::pack&lt; type::fix_int32 &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a374c0b3708a54159a0fe637fff50cfdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_fix_int64 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing uint8 (fixed packed type). </p>
<p>The packed type is always int64. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1fix__int64_01_4.html#ad99782ae93f21e26508e7d4b51a4eb64">msgpack::adaptor::pack&lt; type::fix_int64 &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a5cc0eb3ff2052a9bbaf3273dfae0df2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_fix_int8 </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing uint8 (fixed packed type). </p>
<p>The packed type is always int8. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1fix__int8_01_4.html#a204b68ed917abfd5f79f0cfd80f9a113">msgpack::adaptor::pack&lt; type::fix_int8 &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="aa5fb4643e92d848275f8c8811587f20e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_fix_uint16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing uint8 (fixed packed type). </p>
<p>The packed type is always uint16. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1fix__uint16_01_4.html#a30e4953c680d3e40aed8bbb9a689d4af">msgpack::adaptor::pack&lt; type::fix_uint16 &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="ab68ee2c065888aa8f544ab2936731a89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_fix_uint32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing uint8 (fixed packed type). </p>
<p>The packed type is always uint32. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1fix__uint32_01_4.html#a5d9216433179a6f53a4f8c2bed24297d">msgpack::adaptor::pack&lt; type::fix_uint32 &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a90c6932565177f025a349d2b7efba1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_fix_uint64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing uint8 (fixed packed type). </p>
<p>The packed type is always uint64. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1fix__uint64_01_4.html#aa772677fa0d41c05425765b1711a57a7">msgpack::adaptor::pack&lt; type::fix_uint64 &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="afc5d862db269817115e99e85f35a532c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_fix_uint8 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing uint8 (fixed packed type). </p>
<p>The packed type is always uint8. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1fix__uint8_01_4.html#ad8f1e88222ecfb5441c224bab24796d8">msgpack::adaptor::pack&lt; type::fix_uint8 &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="acead48b8317443b9faeb0c8ff907d94d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_float </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing float. </p>
<p>The packed type is float32. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-float">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-float</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01float_01_4.html#a2def04d778f7136f8debbdea6c56854c">msgpack::adaptor::pack&lt; float &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a2eaf662cce1c8f9640d76fb3b2999c69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_int </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing int. </p>
<p>The byte size of the packed data depends on <code>d</code>. If <code>d</code> is zero or positive, the packed type is positive fixnum, or uint*, else the packed type is negative fixnum, or int* The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01signed_01int_01_4.html#ad2323a1d28960e584ddda1585b9c0469">msgpack::adaptor::pack&lt; signed int &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a41c788bca228cb5c7cb7db0ff4df52cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_int16 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing int16. </p>
<p>The byte size of the packed data depends on <code>d</code>. If <code>d</code> is zero or positive, the packed type is positive fixnum, uint8, or uint16, else the packed type is negative fixnum, int8, or int16. The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a362c602fb24fa71e485f5006b6a91056"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_int32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing int32. </p>
<p>The byte size of the packed data depends on <code>d</code>. If <code>d</code> is zero or positive, the packed type is positive fixnum, uint8, uint16, or uint32, else the packed type is negative fixnum, int8, int16, or int32. The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1351410e46a4ab831a3034a59f6c02a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_int64 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing int32. </p>
<p>The byte size of the packed data depends on <code>d</code>. If <code>d</code> is zero or positive, the packed type is positive fixnum, uint8, uint16, uint32, or uint64, else the packed type is negative fixnum, int8, int16, int32, or int64. The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="aa8c93e0716843a658b79ae187caa3fc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_int8 </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing int8. </p>
<p>The byte size of the packed data depends on <code>d</code>. If <code>d</code> is zero or positive, the packed type is positive fixnum, or uint8, else the packed type is negative fixnum, or int8 The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9a63eed08c8e1108abdf871559262e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_long </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing long. </p>
<p>The byte size of the packed data depends on <code>d</code>. If <code>d</code> is zero or positive, the packed type is positive fixnum, or uint*, else the packed type is negative fixnum, or int* The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01signed_01long_01_4.html#a01c3b3f218bf386aa1f254c4e5c18bae">msgpack::adaptor::pack&lt; signed long &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="aa8b3d4a90d09c85c9fc66085ccf983bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_long_long </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing long long. </p>
<p>The byte size of the packed data depends on <code>d</code>. If <code>d</code> is zero or positive, the packed type is positive fixnum, or uint*, else the packed type is negative fixnum, or int* The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01signed_01long_01long_01_4.html#a218ebb6d28a98a7fc37429dc89246628">msgpack::adaptor::pack&lt; signed long long &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a56eab2094abd6467245ba135fe884f1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_map </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing map header and size. </p>
<p>The packed type is map header and map size. You need to pack <code>n</code> pairs of msgpack objects following this header and size. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#map-format-family">https://github.com/msgpack/msgpack/blob/master/spec.md#map-format-family</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of array elements (array size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unordered__map_3_01_k_00_01_v_00_01_hash_00_01_compare_00_01_alloc_01_4_01_4.html#a44b14e270d738552c27a78e6fe79c72d">msgpack::adaptor::pack&lt; std::unordered_map&lt; K, V, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1assoc__vector_3_01_k_00_01_v_00_01_compare_00_01_alloc_01_4_01_4.html#a3b379cea5dfe498024fd2f96fd9634ed">msgpack::adaptor::pack&lt; type::assoc_vector&lt; K, V, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unordered__multimap_3_01_k_00_01_v_00_01_hash_00_01_compare_00_01_alloc_01_4_01_4.html#aa72c9d6fd9cae57810917c1242ca12a6">msgpack::adaptor::pack&lt; std::unordered_multimap&lt; K, V, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1map_3_01_k_00_01_v_00_01_compare_00_01_alloc_01_4_01_4.html#a8cf6af75da6d8a82369a395f14828552">msgpack::adaptor::pack&lt; std::map&lt; K, V, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1multimap_3_01_k_00_01_v_00_01_compare_00_01_alloc_01_4_01_4.html#acd3211d8657a30299bb3cd05e2b3b53f">msgpack::adaptor::pack&lt; std::multimap&lt; K, V, Compare, Alloc &gt; &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a8529ab3e807f43304ca88cf1c4378dbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_nil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing nil. </p>
<p>The packed type is nil. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-nil">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-nil</a></p>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1nil__t_01_4.html#a44dd0ccdf163e4b0d243799d1412a16b">msgpack::adaptor::pack&lt; type::nil_t &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1shared__ptr_3_01_t_01_4_01_4.html#aa0fde423b60c4dcf403ccbb5e156d9d6">msgpack::adaptor::pack&lt; std::shared_ptr&lt; T &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unique__ptr_3_01_t_01_4_01_4.html#a3032426d91729dea7bf2f54216c50750">msgpack::adaptor::pack&lt; std::unique_ptr&lt; T &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01boost_1_1optional_3_01_t_01_4_01_4.html#a32e3ee1d03e60b0aea53e4b34ecdb2ba">msgpack::adaptor::pack&lt; boost::optional&lt; T &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a2605d4b70f7135e7dbe445543bbc85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_short </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing short. </p>
<p>The byte size of the packed data depends on <code>d</code>. If <code>d</code> is zero or positive, the packed type is positive fixnum, or uint*, else the packed type is negative fixnum, or int* The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01signed_01short_01_4.html#ab626931a6c1fa54ba2345a6375896539">msgpack::adaptor::pack&lt; signed short &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a6658c16f3d61794ace88f6be0b8af71f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_signed_char </td>
          <td>(</td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing signed char. </p>
<p>The byte size of the packed data depends on <code>d</code>. If <code>d</code> is zero or positive, the packed type is positive fixnum, or uint*, else the packed type is negative fixnum, or int* The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01signed_01char_01_4.html#ad259871d4650f88f55eb2a60a2160240">msgpack::adaptor::pack&lt; signed char &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9d5a612c8ee63afa589f40bd7b18157"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_str </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing str header and length. </p>
<p>The packed type is str header and length. The minimum byte size length expression is used. You need to call <code><a class="el" href="classmsgpack_1_1packer.html#a860e40e4e394e421fa25d5cb2ebb6176" title="Packing str body. ">pack_str_body(const char* b, uint32_t l)</a></code> after this function calling with the same <code>l</code> value. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-str">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-str</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The length of string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01const_01char_01_5_01_4.html#a865efae2565fe58b4b0ed7f96cb51663">msgpack::adaptor::pack&lt; const char * &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1string_01_4.html#a48c68bf4268c23f4a645624edf6f695c">msgpack::adaptor::pack&lt; std::string &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01char[_n]_4.html#a8c1211cddd275a8bca1f16d6f23a354b">msgpack::adaptor::pack&lt; char[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01const_01char[_n]_4.html#a6ef3c26d519c1ac2cedab7dda032ad51">msgpack::adaptor::pack&lt; const char[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a860e40e4e394e421fa25d5cb2ebb6176"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_str_body </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing str body. </p>
<p>You need to call this function just after <code><a class="el" href="classmsgpack_1_1packer.html#ab9d5a612c8ee63afa589f40bd7b18157" title="Packing str header and length. ">pack_str(uint32_t l)</a></code> calling. The value <code>l</code> should be the same as <code><a class="el" href="classmsgpack_1_1packer.html#ab9d5a612c8ee63afa589f40bd7b18157" title="Packing str header and length. ">pack_str(uint32_t l)</a></code> argument <code>l</code>. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-str">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-str</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The length of string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01const_01char_01_5_01_4.html#a865efae2565fe58b4b0ed7f96cb51663">msgpack::adaptor::pack&lt; const char * &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1string_01_4.html#a48c68bf4268c23f4a645624edf6f695c">msgpack::adaptor::pack&lt; std::string &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01char[_n]_4.html#a8c1211cddd275a8bca1f16d6f23a354b">msgpack::adaptor::pack&lt; char[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01const_01char[_n]_4.html#a6ef3c26d519c1ac2cedab7dda032ad51">msgpack::adaptor::pack&lt; const char[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a76b903cb70cffe8de7e62e696204c1df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_true </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing true. </p>
<p>The packed type is bool, value is true. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#bool-format-family">https://github.com/msgpack/msgpack/blob/master/spec.md#bool-format-family</a></p>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01bool_01_4.html#a47ca02dc54aae6c18750609e90adcbd7">msgpack::adaptor::pack&lt; bool &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="abf92cb3cb74374a7b64455ba5b2850ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_uint16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing uint16. </p>
<p>The byte size of the packed data depends on <code>d</code>. The packed type is positive fixnum, uint8 or uint16. The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a341e64b414395108295a014a35cc4ea5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_uint32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing uint32. </p>
<p>The byte size of the packed data depends on <code>d</code>. The packed type is positive fixnum, uint8, uint16 or uint32. The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5a1f1b9066d2a8e25a9e4ae697a2dcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_uint64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing uint16. </p>
<p>The byte size of the packed data depends on <code>d</code>. The packed type is positive fixnum, uint8, uint16, uint32 or uint64. The minimum byte size expression is used. positive fixnum, uint8, uint16, or uint32 is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1object_01_4.html#a310f62745d89df227546f6ea3908dda1">msgpack::adaptor::pack&lt; msgpack::object &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">msgpack::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a53f9ec42acac1677e6230bf8b7173d9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_uint8 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing uint8. </p>
<p>The byte size of the packed data depends on <code>d</code>. The packed type is positive fixnum or uint8. The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e21564a3032eec8d81fcf04cf2e3a9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_unsigned_char </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing unsigned char. </p>
<p>The byte size of the packed data depends on <code>d</code>. The packed type is positive fixnum, or uint*. The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01unsigned_01char_01_4.html#a8d7123d37f3d7ed9b535eefd68fc7f74">msgpack::adaptor::pack&lt; unsigned char &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a76b19cb586896d27c2a189e29ba5da05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_unsigned_int </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing unsigned int. </p>
<p>The byte size of the packed data depends on <code>d</code>. The packed type is positive fixnum, or uint*. The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01unsigned_01int_01_4.html#acef8633becc7bb614d4f6c50f70023e3">msgpack::adaptor::pack&lt; unsigned int &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="acda055796ee2b592252127e6597e4bb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_unsigned_long </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing unsigned long. </p>
<p>The byte size of the packed data depends on <code>d</code>. The packed type is positive fixnum, or uint*. The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01unsigned_01long_01_4.html#a8015406935dc3ce1edde909595e9b8c3">msgpack::adaptor::pack&lt; unsigned long &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9bc770dd6b18e5548bbb05cbb53f430"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_unsigned_long_long </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing unsigned long long. </p>
<p>The byte size of the packed data depends on <code>d</code>. The packed type is positive fixnum, or uint*. The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01unsigned_01long_01long_01_4.html#a8b0257c0d1eceb35e2824bbbd6952b2e">msgpack::adaptor::pack&lt; unsigned long long &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b07b6f50010a25723924becb2f0049f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_unsigned_short </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing unsigned short. </p>
<p>The byte size of the packed data depends on <code>d</code>. The packed type is positive fixnum, or uint*. The minimum byte size expression is used. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-int</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a packing object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01unsigned_01short_01_4.html#afd858848cf11f7143a984fdae09a1508">msgpack::adaptor::pack&lt; unsigned short &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b934eab99f33b1558c447314d80592f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_v4raw </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing raw (v4) header and length. </p>
<p>The packed type is raw header and length. The minimum byte size length expression is used. The format raw (v4) is old MessagePack version4 format. You need to call <code><a class="el" href="classmsgpack_1_1packer.html#a743bc909852b9ff89e5c5d033d0aed25" title="Packing raw (v4) body. ">pack_v4raw_body(const char* b, uint32_t l)</a></code> after this function calling with the same <code>l</code> value. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-str">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-str</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The length of string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1v4raw__ref_01_4.html#ab85c48448e0fd0421f2f42366bcb4faf">msgpack::adaptor::pack&lt; type::v4raw_ref &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a743bc909852b9ff89e5c5d033d0aed25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">packer</a>&lt; Stream &gt; &amp; <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt;::pack_v4raw_body </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packing raw (v4) body. </p>
<p>The format raw (v4) is old MessagePack version4 format. You need to call this function just after <code><a class="el" href="classmsgpack_1_1packer.html#a1b934eab99f33b1558c447314d80592f" title="Packing raw (v4) header and length. ">pack_v4raw(uint32_t l)</a></code> calling. The value <code>l</code> should be the same as <code><a class="el" href="classmsgpack_1_1packer.html#a1b934eab99f33b1558c447314d80592f" title="Packing raw (v4) header and length. ">pack_v4raw(uint32_t l)</a></code> argument <code>l</code>. See <a href="https://github.com/msgpack/msgpack/blob/master/spec.md#formats-str">https://github.com/msgpack/msgpack/blob/master/spec.md#formats-str</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The length of string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference of <code>*this</code>. </dd></dl>

<p>Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1v4raw__ref_01_4.html#ab85c48448e0fd0421f2f42366bcb4faf">msgpack::adaptor::pack&lt; type::v4raw_ref &gt;::operator()()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/kondo/work/msgpack-c/include/msgpack/v1/adaptor/<a class="el" href="v1_2adaptor_2adaptor__base__decl_8hpp_source.html">adaptor_base_decl.hpp</a></li>
<li>/home/kondo/work/msgpack-c/include/msgpack/v1/<a class="el" href="v1_2pack_8hpp_source.html">pack.hpp</a></li>
<li>/home/kondo/work/msgpack-c/include/msgpack/v1/<a class="el" href="v1_2object_8hpp_source.html">object.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
